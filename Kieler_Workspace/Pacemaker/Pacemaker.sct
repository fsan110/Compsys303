
scchart DDDPacemaker{
   
  //@note By sets and relations theory each state can have
  //	  one unique output for each input.
  //	  Not sure how to stop LRI and AVI, AEI timer for 
  // 	  in C. Either check signal_ex or signal_stop for that
  
  /*Control signals, external inputs and status signals*/
  input signal VSense, ASense;
  //For simulation purpose only. To be emitted by peripherals
  input signal VRPTO, LRITO, URITO, AVITO, PVARPTO, AEITO;
  output signal VPace, APace;
  
  /*Timer signals*/
  //VRP
  output signal VRP_start, VRP_stop;
  //LRI
  output signal LRI_start, LRI_stop;
  //URI
  output signal URI_start, URI_stop;
  //AVI
  output signal AVI_start, AVI_stop;
  //PVARP
  output signal PVARP_start, PVARP_stop;
  //AEI
  output signal AEI_start, AEI_stop;
  
   initial state ControlUnit{
   
   /*Internal Signals*/
   signal VRP_ex, LRI_ex, URI_ex, AVI_ex, PVARP_ex, AEI_ex;
   
   region VRP_timer:
   		initial state idle
   			--> timer with VRP_start ;
   	
   		state timer
   			--> idle with VRPTO / VRP_ex;

   region VRP:
	
		initial state idle
			--> waitVRP with VSense && (URI_start && LRI_start) / VRP_start
			--> waitVRP with VPace && (URI_start && LRI_start) / VRP_start;
    	
    	state waitVRP
    		--> idle with VRP_ex / VRP_stop
    		--> waitVRP with VSense;
    			
   region LRI_timer:
    	initial state idle
    		--> timer immediate with LRI_start;
    	
    	state timer
    		--> idle with LRI_stop 
    		--> idle with LRITO / LRI_ex;
    	
    region LRI:
    	initial state idle
    		--> waitVRP with VSense / LRI_start;
    	
    	state waitVRP
    		--> waitURI_exit with VRP_ex;
    	
    	state waitURI_exit
    		--> waitLRI with URI_ex;
    	
    	//Timer will be stopped with either LRI_stop or LRI_ex		
    	state waitLRI 
    		--> intState with VSense || VPace / LRI_stop
    		--> intState with LRI_ex / VPace;
    			
    	state intState
    		--> waitVRP immediate with / LRI_start;
    		
 	region URI:
 		initial state idle
    		--> waitVRP with (VSense || VPace) / URI_start;
    		
    	state waitVRP
    		--> waitURI with VRP_ex;
    	
    	state waitURI
    		--> waitURI with VSense
    		--> idle with URI_ex / URI_stop;
    		    		
    		  		
    region URI_timer:
    	initial state idle
    		--> timer with URI_start;
    	
    	state timer
    		--> idle with URITO / URI_ex;
    		
    region PVARP_timer:
    	initial state idle
   			--> timer with PVARP_start ;
   	
   		state timer
   			--> idle with PVARPTO / PVARP_ex;
   			
   	region PVARP:
	
		initial state idle
			--> waitVRP with VSense && (URI_start && LRI_start) / PVARP_start
			--> waitVRP with VPace && (URI_start && LRI_start) / PVARP_start;
			
		state waitVRP
    		--> waitPVARP with VRP_ex;
    		
    	state waitPVARP
    		--> idle with PVARP_ex / PVARP_stop
    		--> waitPVARP with ASense;
    		
    region AEI_timer:
    	
    	initial state idle
    		--> timer with AEI_start;
    	
    	state timer
    		--> idle with AEI_stop 
    		--> idle with AEITO / AEI_ex;
    	
   
    region AEI:
    	
    	initial state idle
			--> waitVRP with VSense / AEI_start
			--> waitVRP with VPace  / AEI_start;
			
		state waitVRP
			--> waitPVARP with VRP_ex;
		
		state waitPVARP
			--> waitAtrial with PVARP_ex;
			
		state waitAtrial
			--> idle with ASense / AEI_stop
			--> idle with AEI_ex / APace;
   
   /* Do not use till AEI is done */
   
   
    		
//    region AVI_timer:
//    	initial state idle
//    		--> timer with AVI_start;
//    	
//    	state timer
//    		--> idle with AVI_stop 
//    		--> idle with AVITO / AVI_ex;
//    		
//    region AVI:
//    	initial state idle
//    		//Change to priority 
//    		--> wait with ASense || APace / AVI_start;
//    		
//    	state wait
//    		--> waitAVI with URI_ex
//    		--> waitURI with AVI_ex;
//    		
//    	state waitAVI
//			Does not like this yet. Waiting on PVARP and AEI implementation
//    		--> idle with (VPace || VSense) / AVI_stop
//    		--> idle with AVI_ex / VPace;
//    		
//    	state waitURI
//    		--> idle with pre(URI_ex) / VPace;
//    		
    	 				
	};
   
}
