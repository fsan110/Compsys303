
scchart DDDPacemaker{
   
  //@note By sets and relations theory each state can have
  //	  one unique output for the same input.
  //@note Not sure how to stop LRI and AVI, AEI timer for timeouts
  // 	  in C. Either check signal_ex or signal_stop for that
  //@note LRI timer needs to be stopped and started in same tick().
  //	  This is as per diagram.
  //@note Pre(signal) has been used in some places to sync state
  //	  transitions
  
  
  /*Control signals, external inputs and status signals*/
  input signal VSense, ASense;
  //For simulation purpose only. To be emitted by peripherals
  input signal VRPTO, LRITO, URITO, AVITO, PVARPTO, AEITO;
  output signal VPace, APace;
  
  /*Timer signals*/
  //VRP
  output signal VRP_start, VRP_stop;
  //LRI
  output signal LRI_start, LRI_stop;
  //URI
  output signal URI_start, URI_stop;
  //AVI
  output signal AVI_start, AVI_stop;
  //PVARP
  output signal PVARP_start, PVARP_stop;
  //AEI
  output signal AEI_start, AEI_stop;
  
   initial state ControlUnit{
   
   /*Internal Signals*/
   signal VRP_ex, LRI_ex, URI_ex, AVI_ex, PVARP_ex, AEI_ex;
   
   region VRP_timer:
   		initial state idle
   			--> timer with VRP_start ;
   	
   		state timer
   			--> idle with VRPTO / VRP_ex;

   region VRP:
	
		initial state idle
			--> waitVRP with VPace && (URI_start && LRI_start) / VRP_start
			--> waitVRP with VSense && (URI_start && LRI_start) / VRP_start;
    	
    	state waitVRP
    		--> idle with VRP_ex / VRP_stop
    		--> waitVRP with VSense;
    			
   region LRI_timer:
    	initial state idle
    		--> timer immediate with LRI_start;
    	
    	state timer
    		--> idle with LRI_stop 
    		--> idle with LRITO / LRI_ex;
    	
    region LRI:
    	initial state idle
    		--> waitVRP with VPace / LRI_start
    		--> waitVRP with VSense / LRI_start;
    	
    	state waitVRP
    		--> waitURI_exit with VRP_ex;
    	
    	state waitURI_exit
    		--> waitLRI with URI_ex;
    	
    			
    	state waitLRI 
    		--> intState with VSense || VPace / LRI_stop
    		--> intState with LRI_ex / VPace;
    			
    	state intState
    		--> waitVRP immediate with / LRI_start;
    		
 	region URI:
 		initial state idle
    		--> waitVRP with VPace / URI_start
    		--> waitVRP with VSense / URI_start;
    		
    	state waitVRP
    		--> waitURI with VRP_ex;
    	
    	state waitURI
    		--> waitURI with VSense
    		--> idle with URI_ex / URI_stop;
    		    		
    		  		
    region URI_timer:
    	initial state idle
    		--> timer with URI_start;
    	
    	state timer
    		--> idle with URITO / URI_ex;
    		
    region PVARP_timer:
    	initial state idle
   			--> timer with PVARP_start ;
   	
   		state timer
   			--> idle with PVARPTO / PVARP_ex;
   			
   	region PVARP:
	
		initial state idle
			--> waitVRP with VSense && (URI_start && LRI_start) / PVARP_start
			--> waitVRP with VPace && (URI_start && LRI_start) / PVARP_start;
			
		state waitVRP
    		--> waitPVARP with VRP_ex;
    		
    	state waitPVARP
    		--> idle with PVARP_ex / PVARP_stop
    		--> waitPVARP with ASense;
    		
    region AEI_timer:
    	
    	initial state idle
    		--> timer with AEI_start;
    	
    	state timer
    		--> idle with AEI_stop 
    		--> idle with AEITO / AEI_ex;
    	
   
    region AEI:
    	
    	initial state idle
			--> waitVRP with VSense / AEI_start
			--> waitVRP with VPace  / AEI_start;
			
		state waitVRP
			--> waitPVARP with VRP_ex;
		
		state waitPVARP
			--> waitAtrial with PVARP_ex;
			
		state waitAtrial
			--> idle with ASense / AEI_stop
			--> idle with AEI_ex / APace;
	
			    		
    region AVI_timer:
    	initial state idle
    		--> timer with AVI_start;
    	
    	state timer
    		--> idle with AVI_stop 
    		--> idle with AVITO / AVI_ex;
    		
    region AVI:
    	initial state idle
    		--> waitAVI with ASense / AVI_start
    		--> waitVRP with VPace
    		--> waitVRP with VSense;
    		
    	state waitVRP
			--> waitPVARP with VRP_ex;
    		
    		
    	state waitPVARP
    		--> waitAtrial with PVARP_ex; 
    			
    	state waitAtrial
    		--> wait with APace / AVI_start
    		--> wait with ASense / AVI_start;
    			
    	state wait
    		--> waitAVI with URI_ex
    		--> waitURI;
    		
    	state waitURI {exit / AVI_stop;}
    		//AVI_is stopped when URI has finished
    		--> waitPVARP with pre(URI_ex) / VPace;
    		
    	state waitAVI
			/*Does not like two transitions in this state at all
			  Have to use connector/blank. 
			 Cannot explain this part.
			 Good news is timing seems to be synced */
    		--> waitPVARP with (VPace || VSense) / AVI_stop
    		--> AVI_Pace with AVI_ex;
    		
    	state AVI_Pace {exit / VPace;}
    		//Only works with exit function.
    		--> waitPVARP;
    		
    	 				
	};
   
}

/*
 * DDD Mode PaceMaker
 */
//scchart PaceMaker {
//  input signal AS, VS; //Heart events
//  input signal R; //Debug only reset singal
//  
//  //Timer has expired
//  input signal AVI_EVENT, PVARP_EVENT,VRP_EVENT,AEI_EVENT,LRI_EVENT,URI_EVENT;
//  
//  //Pace heart
//  output signal APACE,VPACE;
//  
//  //Start timers
//  output signal AVI_START,PVARP_START,VRP_START,AEI_START,LRI_START,URI_START;
//  
//  //Stop Timers
//  output signal AVI_STOP,AEI_STOP;
//  
//  //Internal use for debugging see if heart event was not a refractory signal
//  output signal VACCEPT,AACCEPT;
//  
//  
//  
//  region Main:
//  
//  initial state PACEMAKER {
//    
//    initial state main {
//      
//      //Timers that start to V signals
//      region VTIMERS:
//      initial state tick
//      --> tick with VACCEPT/VRP_START;PVARP_START;URI_START;AEI_START;LRI_START;      
//      
//      //Timer reactions to A signals
//      region ATIMERS:
//      initial state tick
//      --> tick with AACCEPT/AVI_START;AEI_STOP;  
//      
//      //Stop AVI
//      region AVI_STOP:
//      initial state tick
//      --> tick with VACCEPT/AVI_STOP;
//      
//      region AACEPT_LOGIC:
//      initial state init{
//        
//        //Initially when no timer have started any A signal is accepted
//        region init_region:
//        initial state init
//        --> final_state with AS/AACCEPT;
//        final state final_state;
//      }
//      >-> continuous 
//      --> continuous with VACCEPT;
//      
//      //Once timers have started wait for PVARP to end before accepting
//      state continuous{
//        region continous_region:
//        initial state init
//        --> refactory_over with PVARP_EVENT;
//        state refactory_over
//        --> refactory_over with AS/AACCEPT;
//      }
//      --> continuous with PVARP_START;
//      
//      
//      region VACCEPT_LOGIC:
//      //Initially when no timer have started any V signal is accepted
//      initial state init
//      --> continuous with VS/VACCEPT;
//      
//      //Once timers have started wait for VRP to end before accepting
//      state continuous{
//        region continuous_region:
//        initial state init
//        --> safe with VRP_EVENT;
//        state safe
//        --> safe with VS/VACCEPT;
//      }
//      --> continuous with VRP_START;
//      
//      //Pace when AEI expires 
//      region APACE_LOGIC:
//      initial state AEI_PACE{
//        region logic:
//        initial state init
//      	o-> safe  with AACCEPT
//      	--> paceA with AEI_EVENT/APACE;AACCEPT;
//      	state paceA;
//      	state safe;
//      }
//      --> AEI_PACE with AEI_START;
//      
//      //Pace when LRI or AVI expires but wait for URI before sending
//      region VPACE_LOGIC:
//      
//      //Initially AVI can expire with URI not running in this case we pace immediately 
//      initial state before_v{
//        region before_v_region:
//        initial state init
//        o-> end with VACCEPT
//        --> end with AVI_EVENT/VPACE;VACCEPT;
//        final state end;
//      }
//      >-> after_v;
//      
//      //This state is continuous once we have a VACCEPT
//      state after_v{
//        region after_v_region:
//        initial state wait_uri
//        
//        //URI has priority so we handle the case URI expires in same tick as LRI or AVI
//        o-> uri_done with URI_EVENT
//        --> delay_uri with LRI_EVENT || AVI_EVENT;
//        state uri_done
//        //If we want to pace at the same time we get an VACCEPT cancel the pace
//        o-> safe immediate with VACCEPT
//        --> vpace immediate with LRI_EVENT || AVI_EVENT / VPACE;VACCEPT;
//        state delay_uri
//        //If we want to pace at the same time we get an VACCEPT cancel the pace
//        o-> safe immediate with VACCEPT
//        --> vpace immediate with URI_EVENT / VPACE;VACCEPT;
//        state safe;
//        state vpace;
//      }
//      --> after_v with URI_START;
//      
//      
//    };
//    
//    
//    
//  }
//  o-> PACEMAKER with R;
//}
