
scchart DDDPacemaker{
   
  //@note By sets and relations theory each state can have
  //	  one unique output for the same input.
  //@note Not sure how to stop LRI and AVI, AEI timer for timeouts
  // 	  in C. Either check signal_ex or signal_stop for that
  //@note LRI timer needs to be stopped and started in same tick().
  //	  This is as per diagram.
  //@note Pre(signal) has been used in some places to sync state
  //	  transitions
  
  
  /*Control signals, external inputs and status signals*/
  input signal VSense, ASense;
  //For simulation purpose only. To be emitted by peripherals
  input signal VRPTO, LRITO, URITO, AVITO, PVARPTO, AEITO;
  output signal VPace, APace;
  
  /*Timer signals*/
  //VRP
  output signal VRP_start, VRP_stop;
  //LRI
  output signal LRI_start, LRI_stop;
  //URI
  output signal URI_start, URI_stop;
  //AVI
  output signal AVI_start, AVI_stop;
  //PVARP
  output signal PVARP_start, PVARP_stop;
  //AEI
  output signal AEI_start, AEI_stop;
  
   initial state ControlUnit{
   
   /*Internal Signals*/
   signal VRP_ex, LRI_ex, URI_ex, AVI_ex, PVARP_ex, AEI_ex;
   
   region VRP_timer:
   		initial state idle
   			--> timer with VRP_start ;
   	
   		state timer
   			--> idle with VRPTO / VRP_ex;

   region VRP:
	
		initial state idle
			--> waitVRP with VPace && (URI_start && LRI_start) / VRP_start
			--> waitVRP with VSense && (URI_start && LRI_start) / VRP_start;
    	
    	state waitVRP
    		--> idle with VRP_ex / VRP_stop
    		--> waitVRP with VSense;
    			
   region LRI_timer:
   		
    	initial state idle   		
    		--> timer immediate with LRI_start;
    	
    	state timer
    		--> idle with LRI_stop 
    		--> idle with LRITO / LRI_ex;
    	
    region LRI:
    	
    	initial state idle
    		
    		--> waitVRP with VPace / LRI_start
    		--> waitVRP with VSense / LRI_start;
    	
    	state waitVRP
    		--> waitURI_exit with VRP_ex;
    	
    	state waitURI_exit
    		--> waitLRI with URI_ex;
    	
    			
    	state waitLRI 
    		--> waitVRP with VSense || VPace / LRI_stop
    		--> waitVRP with LRI_ex / VPace; LRI_start;
    			
    		
 	region URI:
 		initial state idle
    		--> waitVRP with VPace / URI_start
    		--> waitVRP with VSense / URI_start;
    		
    	state waitVRP
    		--> waitURI with VRP_ex;
    	
    	state waitURI
    		--> waitURI with VSense
    		--> idle with URI_ex / URI_stop;
    		    		
    		  		
    region URI_timer:
    	initial state idle
    		--> timer with URI_start;
    	
    	state timer
    		--> idle with URITO / URI_ex;
    		
    region PVARP_timer:
    	initial state idle
   			--> timer with PVARP_start ;
   	
   		state timer
   			--> idle with PVARPTO / PVARP_ex;
   			
   	region PVARP:
	
		initial state idle
			--> waitVRP with VSense && (URI_start && LRI_start) / PVARP_start
			--> waitVRP with VPace && (URI_start && LRI_start) / PVARP_start;
			
		state waitVRP
    		--> waitPVARP with VRP_ex;
    		
    	state waitPVARP
    		--> idle with PVARP_ex / PVARP_stop
    		--> waitPVARP with ASense;
    		
    region AEI_timer:
    	
    	initial state idle
    		--> timer with AEI_start;
    	
    	state timer
    		--> idle with AEI_stop 
    		--> idle with AEITO / AEI_ex;
    	
   
    region AEI:
    	
    	initial state idle
			--> waitVRP with VSense / AEI_start
			--> waitVRP with VPace  / AEI_start;
			
		state waitVRP
			--> waitPVARP with VRP_ex;
		
		state waitPVARP
			--> waitAtrial with PVARP_ex;
			
		state waitAtrial
			--> idle with ASense / AEI_stop
			--> idle with AEI_ex / APace;
	
			    		
    region AVI_timer:
    	initial state idle
    		--> timer with AVI_start;
    	
    	state timer
    		--> idle with AVI_stop 
    		--> idle with AVITO / AVI_ex;
    		
    region AVI:
    	initial state idle
    		--> waitAVI with ASense / AVI_start
    		--> waitVRP with VPace
    		--> waitVRP with VSense;
    		
    	state waitVRP
			--> waitPVARP with VRP_ex;
    		
    		
    	state waitPVARP
    		--> waitAtrial with PVARP_ex; 
    			
    	state waitAtrial
    		--> wait with APace / AVI_start
    		--> wait with ASense / AVI_start;
    			
    	state wait
    		--> waitAVI with URI_ex
    		--> waitURI;
    		
    	state waitURI {exit / AVI_stop;}
    		//AVI_is stopped when URI has finished
    		--> waitPVARP with pre(URI_ex) / VPace;
    		
    	state waitAVI
			/*Does not like two transitions in this state at all
			  Have to use connector/blank. 
			 Cannot explain this part.
			 Good news is timing seems to be synced */
    		--> waitPVARP with (VPace || VSense) / AVI_stop
    		--> AVI_Pace with AVI_ex;
    		
    	state AVI_Pace {exit / VPace;}
    		//Only works with exit function.
    		--> waitPVARP;
    		
    	 				
	};
   
}

